# 金融数据分析实战练习项目

## 项目概述
通过一个完整的银行数据分析项目，综合运用 SQL、Pandas 和知识图谱技术进行金融关系挖掘和智能分析。

## 项目结构
```
Financial_Data_Analysis/
├── data/                          # 数据文件
│   ├── customers.csv              # 客户信息
│   ├── accounts.csv               # 账户信息
│   ├── transactions.csv           # 交易记录
│   └── sample_database.db         # SQLite数据库
├── sql_scripts/                   # SQL脚本
│   ├── 01_data_preparation.sql
│   ├── 02_basic_analysis.sql
│   └── 03_risk_analysis.sql
├── python_scripts/                # Python脚本
│   ├── 01_data_cleaning.py
│   ├── 02_pandas_analysis.py
│   └── 03_knowledge_graph.py
└── results/                       # 分析结果
    ├── reports/
    ├── visualizations/
    └── risk_alerts/
```

## 第一阶段：数据准备与清洗

### 1.1 SQL 数据准备
```sql
-- 创建客户表
CREATE TABLE customers (
    customer_id INTEGER PRIMARY KEY,
    customer_name VARCHAR(100) NOT NULL,
    id_card VARCHAR(18) UNIQUE,
    phone VARCHAR(20),
    address VARCHAR(200),
    customer_type VARCHAR(20) CHECK (customer_type IN ('个人', '企业')),
    created_date DATE,
    last_update_date TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- 创建账户表
CREATE TABLE accounts (
    account_id INTEGER PRIMARY KEY,
    account_number VARCHAR(30) UNIQUE NOT NULL,
    customer_id INTEGER NOT NULL,
    account_type VARCHAR(20) CHECK (account_type IN ('储蓄', '支票', '信用')),
    balance DECIMAL(18,2) DEFAULT 0,
    currency VARCHAR(10) DEFAULT 'CNY',
    status VARCHAR(20) DEFAULT '活跃' CHECK (status IN ('活跃', '冻结', '销户')),
    created_date DATE,
    FOREIGN KEY (customer_id) REFERENCES customers(customer_id)
);

-- 创建交易表
CREATE TABLE transactions (
    transaction_id BIGINT PRIMARY KEY,
    from_account_id INTEGER,
    to_account_id INTEGER,
    amount DECIMAL(18,2) NOT NULL,
    transaction_type VARCHAR(20) NOT NULL CHECK (transaction_type IN ('转账', '存款', '取款')),
    transaction_date TIMESTAMP NOT NULL,
    description VARCHAR(200),
    channel VARCHAR(20),
    FOREIGN KEY (from_account_id) REFERENCES accounts(account_id),
    FOREIGN KEY (to_account_id) REFERENCES accounts(account_id)
);

-- 创建索引
CREATE INDEX idx_accounts_customer ON accounts(customer_id);
CREATE INDEX idx_transactions_from_account ON transactions(from_account_id);
CREATE INDEX idx_transactions_to_account ON transactions(to_account_id);
CREATE INDEX idx_transactions_date ON transactions(transaction_date);
```

### 1.2 Python 数据清洗
```python
import pandas as pd
import numpy as np
import sqlite3
from datetime import datetime, timedelta

def clean_customer_data(df):
    """清洗客户数据"""

    # 1. 去重
    df = df.drop_duplicates(subset=['id_card'], keep='first')

    # 2. 处理缺失值
    df['phone'] = df['phone'].fillna('未知')
    df['address'] = df['address'].fillna('未知')

    # 3. 数据格式化
    df['customer_name'] = df['customer_name'].str.strip()
    df['phone'] = df['phone'].astype(str).str.replace(r'[^\d]', '', regex=True)

    # 4. 身份证号验证
    df = df[df['id_card'].str.len() == 18]

    # 5. 创建日期标准化
    df['created_date'] = pd.to_datetime(df['created_date'], errors='coerce')
    df = df.dropna(subset=['created_date'])

    return df

def clean_account_data(df):
    """清洗账户数据"""

    # 1. 余额异常值处理
    df = df[(df['balance'] >= 0) & (df['balance'] <= 100000000)]  # 合理范围

    # 2. 账户状态标准化
    df['status'] = df['status'].fillna('活跃')
    df['status'] = df['status'].replace({'正常': '活跃', '异常': '冻结'})

    # 3. 去重（同一客户的相同类型账户只保留最新的）
    df = df.sort_values('created_date').drop_duplicates(
        subset=['customer_id', 'account_type'], keep='last'
    )

    return df

def generate_sample_data():
    """生成示例数据"""

    # 客户数据
    customers = pd.DataFrame({
        'customer_id': range(1, 1001),
        'customer_name': [f'客户_{i}' for i in range(1, 1001)],
        'id_card': [f'{i:018d}' for i in range(110000000000000000, 110000000000001000)],
        'phone': [f'138{str(i).zfill(8)}' for i in range(10000000, 10001000)],
        'address': [f'北京市朝阳区某某路{i}号' for i in range(1, 1001)],
        'customer_type': np.random.choice(['个人', '企业'], 1000, p=[0.8, 0.2]),
        'created_date': pd.date_range('2020-01-01', periods=1000, freq='D')
    })

    # 账户数据
    accounts = []
    for i in range(1, 1001):
        num_accounts = np.random.randint(1, 4)
        for j in range(num_accounts):
            accounts.append({
                'account_id': len(accounts) + 1,
                'account_number': f'622202{i:06d}{j:02d}',
                'customer_id': i,
                'account_type': np.random.choice(['储蓄', '支票', '信用']),
                'balance': np.random.lognormal(10, 1.5),
                'currency': 'CNY',
                'status': np.random.choice(['活跃', '活跃', '活跃', '冻结'], p=[0.9, 0.05, 0.03, 0.02]),
                'created_date': pd.Timestamp('2020-01-01') + pd.Timedelta(days=np.random.randint(0, 1460))
            })

    accounts_df = pd.DataFrame(accounts)

    # 交易数据
    transactions = []
    for i in range(10000):
        from_account = np.random.choice(accounts_df['account_id'])
        to_account = np.random.choice(accounts_df['account_id'])

        while to_account == from_account:
            to_account = np.random.choice(accounts_df['account_id'])

        transactions.append({
            'transaction_id': i + 1,
            'from_account_id': from_account,
            'to_account_id': to_account,
            'amount': np.random.lognormal(8, 1),
            'transaction_type': np.random.choice(['转账', '转账', '存款', '取款'], p=[0.6, 0.6, 0.2, 0.2]),
            'transaction_date': pd.Timestamp('2024-01-01') + pd.Timedelta(hours=np.random.randint(0, 8760)),
            'description': f'交易描述_{i}',
            'channel': np.random.choice(['网银', '手机银行', 'ATM', '柜台'])
        })

    transactions_df = pd.DataFrame(transactions)

    return customers, accounts_df, transactions_df

def load_data_to_database(customers, accounts, transactions, db_path='data/sample_database.db'):
    """加载数据到SQLite数据库"""

    conn = sqlite3.connect(db_path)

    # 清洗数据
    customers = clean_customer_data(customers)
    accounts = clean_account_data(accounts)

    # 加载数据
    customers.to_sql('customers', conn, if_exists='replace', index=False)
    accounts.to_sql('accounts', conn, if_exists='replace', index=False)
    transactions.to_sql('transactions', conn, if_exists='replace', index=False)

    conn.commit()
    conn.close()

    print(f"数据已加载到数据库: {db_path}")
    print(f"客户数: {len(customers)}")
    print(f"账户数: {len(accounts)}")
    print(f"交易数: {len(transactions)}")

# 使用示例
if __name__ == "__main__":
    customers, accounts, transactions = generate_sample_data()
    load_data_to_database(customers, accounts, transactions)
```

## 第二阶段：SQL 数据分析

### 2.1 基础业务分析
```sql
-- 查询1：客户基础统计
SELECT
    customer_type,
    COUNT(*) as customer_count,
    AVG(account_count) as avg_accounts_per_customer,
    AVG(total_balance) as avg_total_balance
FROM (
    SELECT
        c.customer_id,
        c.customer_type,
        COUNT(a.account_id) as account_count,
        SUM(a.balance) as total_balance
    FROM customers c
    LEFT JOIN accounts a ON c.customer_id = a.customer_id
    GROUP BY c.customer_id, c.customer_type
) customer_stats
GROUP BY customer_type;

-- 查询2：高频交易客户
WITH customer_transaction_stats AS (
    SELECT
        c.customer_id,
        c.customer_name,
        COUNT(t.transaction_id) as transaction_count,
        SUM(CASE WHEN t.transaction_type = '转账' THEN 1 ELSE 0 END) as transfer_count,
        SUM(t.amount) as total_amount,
        AVG(t.amount) as avg_amount
    FROM customers c
    JOIN accounts a ON c.customer_id = a.customer_id
    LEFT JOIN transactions t ON a.account_id IN (t.from_account_id, t.to_account_id)
    WHERE t.transaction_date >= date('now', '-30 days')
    GROUP BY c.customer_id, c.customer_name
)
SELECT *
FROM customer_transaction_stats
WHERE transaction_count > 50
ORDER BY transaction_count DESC;

-- 查询3：大额交易监控
SELECT
    t.transaction_id,
    c_from.customer_name as from_customer,
    c_to.customer_name as to_customer,
    t.amount,
    t.transaction_date,
    t.channel
FROM transactions t
JOIN accounts a_from ON t.from_account_id = a_from.account_id
JOIN accounts a_to ON t.to_account_id = a_to.account_id
JOIN customers c_from ON a_from.customer_id = c_from.customer_id
JOIN customers c_to ON a_to.customer_id = c_to.customer_id
WHERE t.amount > 100000
AND t.transaction_date >= date('now', '-7 days')
ORDER BY t.amount DESC;
```

### 2.2 关联分析
```sql
-- 查询4：共享电话号码的客户
SELECT
    phone,
    COUNT(*) as customer_count,
    GROUP_CONCAT(customer_name) as customer_names,
    SUM(total_balance) as combined_balance
FROM (
    SELECT
        c.customer_id,
        c.customer_name,
        c.phone,
        COALESCE(a.total_balance, 0) as total_balance
    FROM customers c
    LEFT JOIN (
        SELECT customer_id, SUM(balance) as total_balance
        FROM accounts
        WHERE status = '活跃'
        GROUP BY customer_id
    ) a ON c.customer_id = a.customer_id
    WHERE c.phone != '未知' AND c.phone != ''
) phone_customers
GROUP BY phone
HAVING COUNT(*) > 1
ORDER BY customer_count DESC, combined_balance DESC;

-- 查询5：相互转账分析
WITH customer_pairs AS (
    SELECT
        LEAST(c1.customer_id, c2.customer_id) as customer_id_1,
        GREATEST(c1.customer_id, c2.customer_id) as customer_id_2,
        c1.customer_name as customer_name_1,
        c2.customer_name as customer_name_2,
        COUNT(*) as mutual_transactions,
        SUM(t.amount) as total_amount
    FROM transactions t
    JOIN accounts a1 ON t.from_account_id = a1.account_id
    JOIN accounts a2 ON t.to_account_id = a2.account_id
    JOIN customers c1 ON a1.customer_id = c1.customer_id
    JOIN customers c2 ON a2.customer_id = c2.customer_id
    WHERE c1.customer_id < c2.customer_id
    AND t.transaction_type = '转账'
    GROUP BY c1.customer_id, c2.customer_id, c1.customer_name, c2.customer_name
),
reverse_transactions AS (
    SELECT
        LEAST(c1.customer_id, c2.customer_id) as customer_id_1,
        GREATEST(c1.customer_id, c2.customer_id) as customer_id_2,
        COUNT(*) as reverse_count
    FROM transactions t
    JOIN accounts a1 ON t.from_account_id = a1.account_id
    JOIN accounts a2 ON t.to_account_id = a2.account_id
    JOIN customers c1 ON a1.customer_id = c1.customer_id
    JOIN customers c2 ON a2.customer_id = c2.customer_id
    WHERE c1.customer_id > c2.customer_id
    AND t.transaction_type = '转账'
    GROUP BY c1.customer_id, c2.customer_id
)
SELECT
    cp.customer_name_1,
    cp.customer_name_2,
    cp.mutual_transactions,
    COALESCE(rt.reverse_count, 0) as reverse_transactions,
    cp.total_amount,
    (cp.mutual_transactions + COALESCE(rt.reverse_count, 0)) as total_interactions
FROM customer_pairs cp
LEFT JOIN reverse_transactions rt
    ON cp.customer_id_1 = rt.customer_id_1
    AND cp.customer_id_2 = rt.customer_id_2
WHERE (cp.mutual_transactions + COALESCE(rt.reverse_count, 0)) > 5
ORDER BY total_interactions DESC;
```

## 第三阶段：Pandas 深度分析

### 3.1 客户行为分析
```python
import pandas as pd
import sqlite3
import matplotlib.pyplot as plt
import seaborn as sns
from datetime import datetime, timedelta

class CustomerBehaviorAnalyzer:
    def __init__(self, db_path):
        self.db_path = db_path
        self.conn = sqlite3.connect(db_path)

    def load_data(self):
        """加载数据"""
        self.customers = pd.read_sql("SELECT * FROM customers", self.conn)
        self.accounts = pd.read_sql("SELECT * FROM accounts", self.conn)
        self.transactions = pd.read_sql("SELECT * FROM transactions", self.conn)

        # 数据预处理
        self.transactions['transaction_date'] = pd.to_datetime(self.transactions['transaction_date'])
        self.accounts['created_date'] = pd.to_datetime(self.accounts['created_date'])
        self.customers['created_date'] = pd.to_datetime(self.customers['created_date'])

    def rfm_analysis(self, analysis_date=None):
        """RFM客户分析"""
        if analysis_date is None:
            analysis_date = datetime.now()

        # 获取客户交易数据
        customer_transactions = self.transactions.merge(
            self.accounts[['account_id', 'customer_id']],
            left_on='from_account_id',
            right_on='account_id'
        )

        # 计算RFM指标
        rfm = customer_transactions.groupby('customer_id').agg({
            'transaction_date': lambda x: (analysis_date - x.max()).days,  # Recency
            'transaction_id': 'count',                                     # Frequency
            'amount': 'sum'                                                # Monetary
        }).rename(columns={
            'transaction_date': 'Recency',
            'transaction_id': 'Frequency',
            'amount': 'Monetary'
        })

        # RFM分箱
        rfm['R_Score'] = pd.qcut(rfm['Recency'], 5, labels=[5,4,3,2,1])
        rfm['F_Score'] = pd.qcut(rfm['Frequency'].rank(method='first'), 5, labels=[1,2,3,4,5])
        rfm['M_Score'] = pd.qcut(rfm['Monetary'], 5, labels=[1,2,3,4,5])

        # 计算RFM综合得分
        rfm['RFM_Score'] = rfm['R_Score'].astype(str) + rfm['F_Score'].astype(str) + rfm['M_Score'].astype(str)

        # 客户分群
        def segment_customer(row):
            if row['R_Score'] >= 4 and row['F_Score'] >= 4 and row['M_Score'] >= 4:
                return '重要价值客户'
            elif row['R_Score'] >= 4 and row['F_Score'] >= 4:
                return '重要保持客户'
            elif row['R_Score'] >= 4 and row['M_Score'] >= 4:
                return '重要发展客户'
            elif row['F_Score'] >= 4 and row['M_Score'] >= 4:
                return '重要挽留客户'
            elif row['R_Score'] <= 2 and row['F_Score'] <= 2 and row['M_Score'] <= 2:
                return '流失风险客户'
            else:
                return '一般客户'

        rfm['Segment'] = rfm.apply(segment_customer, axis=1)

        return rfm

    def transaction_pattern_analysis(self):
        """交易模式分析"""

        # 按时间分析交易量
        daily_transactions = self.transactions.set_index('transaction_date').resample('D').agg({
            'transaction_id': 'count',
            'amount': 'sum'
        }).rename(columns={
            'transaction_id': 'transaction_count',
            'amount': 'total_amount'
        })

        # 按小时分析
        self.transactions['hour'] = self.transactions['transaction_date'].dt.hour
        hourly_pattern = self.transactions.groupby('hour').agg({
            'transaction_id': 'count',
            'amount': 'sum'
        })

        # 按星期分析
        self.transactions['weekday'] = self.transactions['transaction_date'].dt.day_name()
        weekday_pattern = self.transactions.groupby('weekday').agg({
            'transaction_id': 'count',
            'amount': 'sum'
        })

        return {
            'daily': daily_transactions,
            'hourly': hourly_pattern,
            'weekday': weekday_pattern
        }

    def anomaly_detection(self):
        """异常交易检测"""

        # 按客户计算交易统计
        customer_stats = self.transactions.groupby('from_account_id').agg({
            'amount': ['mean', 'std', 'count'],
            'transaction_date': ['min', 'max']
        }).fillna(0)

        customer_stats.columns = ['avg_amount', 'std_amount', 'transaction_count', 'first_date', 'last_date']

        # 检测异常大额交易
        anomalies = []
        for _, transaction in self.transactions.iterrows():
            account_id = transaction['from_account_id']
            if account_id in customer_stats.index:
                stats = customer_stats.loc[account_id]
                threshold = stats['avg_amount'] + 3 * stats['std_amount']

                if transaction['amount'] > threshold and transaction['amount'] > 50000:
                    anomalies.append({
                        'transaction_id': transaction['transaction_id'],
                        'from_account_id': account_id,
                        'amount': transaction['amount'],
                        'expected_range': f"{stats['avg_amount']:.2f} ± {3*stats['std_amount']:.2f}",
                        'anomaly_score': transaction['amount'] / threshold
                    })

        return pd.DataFrame(anomalies)

    def visualize_results(self):
        """可视化分析结果"""

        # RFM分析
        rfm = self.rfm_analysis()

        fig, axes = plt.subplots(2, 2, figsize=(15, 12))

        # 客户分群分布
        segment_counts = rfm['Segment'].value_counts()
        axes[0, 0].pie(segment_counts.values, labels=segment_counts.index, autopct='%1.1f%%')
        axes[0, 0].set_title('客户分群分布')

        # 交易模式
        patterns = self.transaction_pattern_analysis()

        # 按小时交易量
        axes[0, 1].bar(patterns['hourly'].index, patterns['hourly']['transaction_id'])
        axes[0, 1].set_title('按小时交易量分布')
        axes[0, 1].set_xlabel('小时')
        axes[0, 1].set_ylabel('交易笔数')

        # 按星期交易量
        weekday_order = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday']
        weekday_data = patterns['weekday'].reindex(weekday_order)
        axes[1, 0].bar(weekday_data.index, weekday_data['transaction_id'])
        axes[1, 0].set_title('按星期交易量分布')
        axes[1, 0].tick_params(axis='x', rotation=45)

        # 客户余额分布
        customer_balances = self.accounts.groupby('customer_id')['balance'].sum()
        axes[1, 1].hist(customer_balances, bins=50, alpha=0.7)
        axes[1, 1].set_title('客户总余额分布')
        axes[1, 1].set_xlabel('总余额')
        axes[1, 1].set_ylabel('客户数量')

        plt.tight_layout()
        plt.savefig('results/visualizations/customer_analysis.png', dpi=300, bbox_inches='tight')
        plt.show()

# 使用示例
analyzer = CustomerBehaviorAnalyzer('data/sample_database.db')
analyzer.load_data()

# RFM分析
rfm_results = analyzer.rfm_analysis()
print("RFM客户分群结果:")
print(rfm_results['Segment'].value_counts())

# 异常检测
anomalies = analyzer.anomaly_detection()
print(f"\n发现异常交易: {len(anomalies)}笔")
print(anomalies.head())

# 可视化
analyzer.visualize_results()
```

## 第四阶段：知识图谱构建与分析

### 4.1 知识图谱构建
```python
import networkx as nx
import sqlite3
from datetime import datetime

class FinancialKnowledgeGraph:
    def __init__(self, db_path):
        self.db_path = db_path
        self.conn = sqlite3.connect(db_path)
        self.graph = nx.DiGraph()

    def build_graph(self):
        """构建金融知识图谱"""

        # 读取数据
        customers = pd.read_sql("SELECT * FROM customers", self.conn)
        accounts = pd.read_sql("SELECT * FROM accounts", self.conn)
        transactions = pd.read_sql("SELECT * FROM transactions", self.conn)

        # 添加客户节点
        for _, customer in customers.iterrows():
            self.graph.add_node(
                f"CUST_{customer['customer_id']}",
                type='Customer',
                name=customer['customer_name'],
                phone=customer['phone'],
                customer_type=customer['customer_type']
            )

        # 添加账户节点
        for _, account in accounts.iterrows():
            self.graph.add_node(
                f"ACC_{account['account_id']}",
                type='Account',
                account_number=account['account_number'],
                balance=account['balance'],
                account_type=account['account_type'],
                status=account['status']
            )

        # 添加客户-账户关系
        for _, account in accounts.iterrows():
            self.graph.add_edge(
                f"CUST_{account['customer_id']}",
                f"ACC_{account['account_id']}",
                relation='HAS_ACCOUNT',
                created_date=account['created_date']
            )

        # 添加交易关系
        for _, transaction in transactions.iterrows():
            if transaction['from_account_id'] and transaction['to_account_id']:
                from_account = f"ACC_{transaction['from_account_id']}"
                to_account = f"ACC_{transaction['to_account_id']}"

                if from_account in self.graph.nodes and to_account in self.graph.nodes:
                    # 找到对应的客户
                    from_customers = list(self.graph.predecessors(from_account))
                    to_customers = list(self.graph.predecessors(to_account))

                    if from_customers and to_customers:
                        self.graph.add_edge(
                            f"CUST_{from_customers[0].split('_')[1]}",
                            f"CUST_{to_customers[0].split('_')[1]}",
                            relation='TRANSFER_TO',
                            amount=transaction['amount'],
                            date=transaction['transaction_date'],
                            transaction_type=transaction['transaction_type']
                        )

    def detect_risk_patterns(self):
        """检测风险模式"""

        risk_alerts = []

        # 1. 检测环形交易
        try:
            cycles = list(nx.simple_cycles(self.graph))
            for cycle in cycles:
                if len(cycle) >= 3:
                    total_amount = 0
                    for i in range(len(cycle)):
                        if self.graph.has_edge(cycle[i], cycle[(i+1)%len(cycle)]):
                            total_amount += self.graph[cycle[i]][cycle[(i+1)%len(cycle)]].get('amount', 0)

                    if total_amount > 100000:
                        risk_alerts.append({
                            'type': 'CIRCULAR_TRANSACTION',
                            'participants': [self.graph.nodes[n]['name'] for n in cycle],
                            'total_amount': total_amount,
                            'risk_level': 'HIGH'
                        })
        except:
            pass

        # 2. 检测高频转账客户
        customer_nodes = [n for n, d in self.graph.nodes(data=True) if d['type'] == 'Customer']

        for customer in customer_nodes:
            out_edges = list(self.graph.out_edges(customer, data=True))
            transfer_edges = [e for e in out_edges if e[2].get('relation') == 'TRANSFER_TO']

            if len(transfer_edges) > 50:
                risk_alerts.append({
                    'type': 'HIGH_FREQUENCY_TRANSFERS',
                    'customer': self.graph.nodes[customer]['name'],
                    'transfer_count': len(transfer_edges),
                    'risk_level': 'MEDIUM'
                })

        # 3. 检测共享信息的客户群
        phone_groups = {}
        for customer in customer_nodes:
            phone = self.graph.nodes[customer].get('phone')
            if phone and phone != '未知':
                if phone not in phone_groups:
                    phone_groups[phone] = []
                phone_groups[phone].append(customer)

        for phone, customers in phone_groups.items():
            if len(customers) > 1:
                total_balance = sum(
                    sum(self.graph.nodes[acc].get('balance', 0)
                        for acc in self.graph.successors(cust)
                        if self.graph.nodes[acc].get('type') == 'Account')
                    for cust in customers
                )

                if total_balance > 1000000:
                    risk_alerts.append({
                        'type': 'SHARED_PHONE_HIGH_BALANCE',
                        'phone': phone,
                        'customers': [self.graph.nodes[c]['name'] for c in customers],
                        'total_balance': total_balance,
                        'risk_level': 'HIGH'
                    })

        return risk_alerts

    def analyze_network_centrality(self):
        """分析网络中心性"""

        # 只分析客户节点
        customer_nodes = [n for n, d in self.graph.nodes(data=True) if d['type'] == 'Customer']
        customer_subgraph = self.graph.subgraph(customer_nodes)

        # 计算中心性指标
        centrality_metrics = {}

        # 度中心性
        degree_centrality = nx.degree_centrality(customer_subgraph)

        # 接近中心性
        try:
            closeness_centrality = nx.closeness_centrality(customer_subgraph)
        except:
            closeness_centrality = {node: 0 for node in customer_nodes}

        # 介数中心性
        betweenness_centrality = nx.betweenness_centrality(customer_subgraph)

        # PageRank
        pagerank = nx.pagerank(self.graph)

        # 合并指标
        for node in customer_nodes:
            centrality_metrics[node] = {
                'name': self.graph.nodes[node]['name'],
                'degree_centrality': degree_centrality.get(node, 0),
                'closeness_centrality': closeness_centrality.get(node, 0),
                'betweenness_centrality': betweenness_centrality.get(node, 0),
                'pagerank': pagerank.get(node, 0)
            }

        return centrality_metrics

    def find_shortest_paths(self, source_customer, target_customer, max_paths=5):
        """查找两个客户之间的最短路径"""

        source_node = f"CUST_{source_customer}"
        target_node = f"CUST_{target_customer}"

        if source_node not in self.graph.nodes or target_node not in self.graph.nodes:
            return []

        try:
            # 查找最短路径
            shortest_path = nx.shortest_path(self.graph, source_node, target_node)

            # 查找多条简单路径
            all_paths = []
            for path in nx.all_simple_paths(self.graph, source_node, target_node, cutoff=4):
                if len(all_paths) >= max_paths:
                    break

                path_details = []
                for i in range(len(path) - 1):
                    edge_data = self.graph[path[i]][path[i+1]]
                    path_details.append({
                        'from': self.graph.nodes[path[i]]['name'],
                        'to': self.graph.nodes[path[i+1]]['name'],
                        'relation': edge_data.get('relation'),
                        'amount': edge_data.get('amount')
                    })
                all_paths.append(path_details)

            return {
                'shortest_path_length': len(shortest_path) - 1,
                'shortest_path': shortest_path,
                'all_paths': all_paths
            }

        except nx.NetworkXNoPath:
            return None

    def export_results(self):
        """导出分析结果"""

        # 风险检测
        risk_alerts = self.detect_risk_patterns()

        # 中心性分析
        centrality = self.analyze_network_centrality()

        # 保存结果
        pd.DataFrame(risk_alerts).to_csv('results/risk_alerts/knowledge_graph_risks.csv', index=False, encoding='utf-8')

        centrality_df = pd.DataFrame.from_dict(centrality, orient='index')
        centrality_df.to_csv('results/reports/customer_centrality_analysis.csv', index=False, encoding='utf-8')

        print(f"知识图谱分析完成:")
        print(f"  节点数: {self.graph.number_of_nodes()}")
        print(f"  边数: {self.graph.number_of_edges()}")
        print(f"  发现风险模式: {len(risk_alerts)}个")
        print(f"  分析客户数: {len(centrality)}个")

# 使用示例
kg = FinancialKnowledgeGraph('data/sample_database.db')
kg.build_graph()
kg.export_results()
```

## 第五阶段：综合报告生成

### 5.1 自动化报告
```python
class FinancialAnalysisReport:
    def __init__(self, db_path):
        self.db_path = db_path
        self.conn = sqlite3.connect(db_path)

    def generate_monthly_report(self, year, month):
        """生成月度分析报告"""

        # 获取当月数据
        start_date = f"{year}-{month:02d}-01"
        if month == 12:
            end_date = f"{year+1}-01-01"
        else:
            end_date = f"{year}-{month+1:02d}-01"

        # 基础统计
        basic_stats = self._get_basic_stats(start_date, end_date)

        # 客户分析
        customer_analysis = self._analyze_customers(start_date, end_date)

        # 风险分析
        risk_analysis = self._analyze_risks(start_date, end_date)

        # 生成报告
        report = self._generate_report_html(
            year, month, basic_stats, customer_analysis, risk_analysis
        )

        # 保存报告
        report_path = f"results/reports/monthly_report_{year}_{month:02d}.html"
        with open(report_path, 'w', encoding='utf-8') as f:
            f.write(report)

        return report_path

    def _get_basic_stats(self, start_date, end_date):
        """获取基础统计数据"""

        # 客户统计
        customer_query = f"""
        SELECT
            customer_type,
            COUNT(*) as customer_count,
            SUM(account_count) as total_accounts,
            SUM(total_balance) as total_balance
        FROM (
            SELECT
                c.customer_id,
                c.customer_type,
                COUNT(a.account_id) as account_count,
                COALESCE(SUM(a.balance), 0) as total_balance
            FROM customers c
            LEFT JOIN accounts a ON c.customer_id = a.customer_id
            GROUP BY c.customer_id, c.customer_type
        ) customer_stats
        GROUP BY customer_type
        """

        customer_stats = pd.read_sql(customer_query, self.conn)

        # 交易统计
        transaction_query = f"""
        SELECT
            transaction_type,
            COUNT(*) as transaction_count,
            SUM(amount) as total_amount,
            AVG(amount) as avg_amount
        FROM transactions
        WHERE transaction_date >= '{start_date}'
        AND transaction_date < '{end_date}'
        GROUP BY transaction_type
        """

        transaction_stats = pd.read_sql(transaction_query, self.conn)

        return {
            'customers': customer_stats,
            'transactions': transaction_stats
        }

    def _generate_report_html(self, year, month, basic_stats, customer_analysis, risk_analysis):
        """生成HTML格式的报告"""

        html_template = f"""
        <!DOCTYPE html>
        <html>
        <head>
            <title>银行数据分析月报 - {year}年{month}月</title>
            <meta charset="utf-8">
            <style>
                body {{ font-family: Arial, sans-serif; margin: 40px; }}
                .header {{ text-align: center; margin-bottom: 30px; }}
                .section {{ margin-bottom: 30px; }}
                .stats-table {{ border-collapse: collapse; width: 100%; }}
                .stats-table th, .stats-table td {{ border: 1px solid #ddd; padding: 8px; text-align: left; }}
                .stats-table th {{ background-color: #f2f2f2; }}
                .alert {{ background-color: #ffe6e6; padding: 10px; border-left: 5px solid #ff4444; margin: 10px 0; }}
                .chart {{ text-align: center; margin: 20px 0; }}
            </style>
        </head>
        <body>
            <div class="header">
                <h1>银行数据分析月报</h1>
                <h2>{year}年{month}月</h2>
                <p>报告生成时间: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}</p>
            </div>

            <div class="section">
                <h3>一、基础统计</h3>
                <h4>客户统计</h4>
                <table class="stats-table">
                    <tr><th>客户类型</th><th>客户数量</th><th>账户总数</th><th>总余额</th></tr>
                    {self._format_customer_stats(basic_stats['customers'])}
                </table>

                <h4>交易统计</h4>
                <table class="stats-table">
                    <tr><th>交易类型</th><th>交易笔数</th><th>总金额</th><th>平均金额</th></tr>
                    {self._format_transaction_stats(basic_stats['transactions'])}
                </table>
            </div>

            <div class="section">
                <h3>二、客户分析</h3>
                {self._format_customer_analysis(customer_analysis)}
            </div>

            <div class="section">
                <h3>三、风险分析</h3>
                {self._format_risk_analysis(risk_analysis)}
            </div>
        </body>
        </html>
        """

        return html_template

    def _format_customer_stats(self, df):
        """格式化客户统计表"""
        rows = ""
        for _, row in df.iterrows():
            rows += f"<tr><td>{row['customer_type']}</td><td>{row['customer_count']}</td><td>{row['total_accounts']}</td><td>{row['total_balance']:,.2f}</td></tr>"
        return rows

    def _format_transaction_stats(self, df):
        """格式化交易统计表"""
        rows = ""
        for _, row in df.iterrows():
            rows += f"<tr><td>{row['transaction_type']}</td><td>{row['transaction_count']}</td><td>{row['total_amount']:,.2f}</td><td>{row['avg_amount']:,.2f}</td></tr>"
        return rows

# 使用示例
report_generator = FinancialAnalysisReport('data/sample_database.db')
report_path = report_generator.generate_monthly_report(2024, 1)
print(f"月度报告已生成: {report_path}")
```

## 项目总结

通过这个完整的实战项目，你将掌握：

1. **SQL技能**：复杂数据查询、聚合分析、关联分析
2. **Pandas技能**：数据清洗、统计分析、可视化、异常检测
3. **知识图谱技能**：图数据构建、网络分析、风险模式识别
4. **金融业务理解**：客户行为分析、风险控制、反欺诈检测

这个项目模拟了真实银行的数据分析场景，可以帮助你快速适应新工作的需求。
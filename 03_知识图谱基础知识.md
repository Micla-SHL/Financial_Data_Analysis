# 知识图谱基础与金融关系分析

## 1. 知识图谱基本概念

### 1.1 什么是知识图谱
知识图谱是一种用图结构表示知识的数据库，包含：
- **实体（Entity）**：现实世界的事物，如客户、公司、账户
- **关系（Relation）**：实体之间的联系，如"持有"、"转账给"
- **属性（Property）**：实体的特征，如客户姓名、账户余额

### 1.2 金融领域典型实体
```python
# 金融知识图谱中的主要实体类型
entities = {
    'Customer': '客户（个人/企业）',
    'Account': '银行账户',
    'Transaction': '交易记录',
    'Company': '企业',
    'Person': '个人',
    'Phone': '电话号码',
    'Address': '地址',
    'IDCard': '身份证号',
    'Bank': '银行机构',
    'Branch': '银行网点'
}

# 典型关系类型
relations = {
    'HAS_ACCOUNT': '拥有账户',
    'IS_GUARANTOR_FOR': '为...担保',
    'TRANSFER_TO': '转账给',
    'SHARE_PHONE': '共享电话',
    'SAME_ADDRESS': '相同地址',
    'IS_DIRECTOR_OF': '担任...董事',
    'IS_SHAREHOLDER_OF': '持有...股份',
    'HAS_TRANSACTION': '发生交易'
}
```

## 2. 图数据库基础

### 2.1 Neo4j 介绍
```cypher
-- 创建节点
CREATE (c:Customer {name: '张三', id_card: '123456789012345678'})
CREATE (a:Account {number: '6222021234567890', balance: 50000})
CREATE (c2:Customer {name: '李四', phone: '13800138001'})

-- 创建关系
MATCH (c:Customer {name: '张三'}), (a:Account {number: '6222021234567890'})
CREATE (c)-[:HAS_ACCOUNT]->(a)

MATCH (c1:Customer {name: '张三'}), (c2:Customer {name: '李四'})
CREATE (c1)-[:TRANSFER_TO {amount: 10000, date: '2024-01-15'}]->(c2)
```

### 2.2 Python 使用 NetworkX
```python
import networkx as nx
import matplotlib.pyplot as plt

# 创建图
G = nx.Graph()

# 添加节点（实体）
G.add_node("C001", type="Customer", name="张三", phone="13800138001")
G.add_node("A001", type="Account", number="6222021234567890", balance=50000)
G.add_node("C002", type="Customer", name="李四", phone="13800138002")

# 添加边（关系）
G.add_edge("C001", "A001", relation="HAS_ACCOUNT")
G.add_edge("C001", "C002", relation="TRANSFER_TO", amount=10000, date="2024-01-15")

# 基本图分析
print(f"节点数量: {G.number_of_nodes()}")
print(f"边数量: {G.number_of_edges()}")
print(f"张三的度数: {G.degree('C001')}")

# 可视化
plt.figure(figsize=(10, 8))
pos = nx.spring_layout(G)
nx.draw(G, pos, with_labels=True, node_color='lightblue', node_size=500)
plt.show()
```

## 3. 银行场景知识图谱构建

### 3.1 客户关系图谱
```python
def build_customer_relationship_graph(customer_data, account_data, transaction_data):
    """构建客户关系图谱"""

    import networkx as nx

    # 创建有向图
    G = nx.DiGraph()

    # 添加客户节点
    for _, customer in customer_data.iterrows():
        G.add_node(
            f"CUST_{customer['customer_id']}",
            type='Customer',
            name=customer['customer_name'],
            phone=customer['phone'],
            id_card=customer['id_card']
        )

    # 添加账户节点
    for _, account in account_data.iterrows():
        G.add_node(
            f"ACC_{account['account_id']}",
            type='Account',
            number=account['account_number'],
            balance=account['balance']
        )

    # 添加客户-账户关系
    for _, account in account_data.iterrows():
        G.add_edge(
            f"CUST_{account['customer_id']}",
            f"ACC_{account['account_id']}",
            relation='HAS_ACCOUNT',
            created_date=account['created_date']
        )

    # 添加交易关系
    for _, transaction in transaction_data.iterrows():
        if transaction['from_account_id'] and transaction['to_account_id']:
            from_customer = account_data[account_data['account_id'] == transaction['from_account_id']]['customer_id'].iloc[0]
            to_customer = account_data[account_data['account_id'] == transaction['to_account_id']]['customer_id'].iloc[0]

            G.add_edge(
                f"CUST_{from_customer}",
                f"CUST_{to_customer}",
                relation='TRANSFER_TO',
                amount=transaction['amount'],
                date=transaction['transaction_date']
            )

    return G
```

### 3.2 隐式关系发现
```python
def discover_hidden_relationships(G):
    """发现隐含关系"""

    hidden_relations = []

    # 1. 共享电话号码的客户
    customers = [n for n, d in G.nodes(data=True) if d['type'] == 'Customer']

    for i, cust1 in enumerate(customers):
        for cust2 in customers[i+1:]:
            phone1 = G.nodes[cust1].get('phone')
            phone2 = G.nodes[cust2].get('phone')

            if phone1 and phone2 and phone1 == phone2:
                hidden_relations.append({
                    'customer1': cust1,
                    'customer2': cust2,
                    'relation_type': 'SHARE_PHONE',
                    'evidence': f"共享电话: {phone1}",
                    'risk_level': 'HIGH'
                })

    # 2. 频繁转账关系
    for u, v, data in G.edges(data=True):
        if data.get('relation') == 'TRANSFER_TO':
            # 检查转账频率
            # 这里需要从交易记录中统计实际频率
            pass

    # 3. 闭环交易检测
    cycles = list(nx.simple_cycles(G))
    for cycle in cycles:
        if len(cycle) >= 3:
            hidden_relations.append({
                'cycle': cycle,
                'relation_type': 'CIRCULAR_TRANSACTION',
                'risk_level': 'MEDIUM'
            })

    return hidden_relations
```

## 4. 图算法在金融风控中的应用

### 4.1 中心性分析
```python
def analyze_centrality(G):
    """分析图中节点的重要性"""

    centrality_metrics = {}

    # 度中心性（直接连接数）
    degree_centrality = nx.degree_centrality(G)

    # 接近中心性（信息传播效率）
    closeness_centrality = nx.closeness_centrality(G)

    # 介数中心性（桥梁作用）
    betweenness_centrality = nx.betweenness_centrality(G)

    # PageRank（影响力）
    pagerank = nx.pagerank(G)

    # 合并指标
    for node in G.nodes():
        if G.nodes[node]['type'] == 'Customer':
            centrality_metrics[node] = {
                'name': G.nodes[node]['name'],
                'degree': degree_centrality[node],
                'closeness': closeness_centrality[node],
                'betweenness': betweenness_centrality[node],
                'pagerank': pagerank[node]
            }

    # 找出关键客户（按PageRank排序）
    key_customers = sorted(
        centrality_metrics.items(),
        key=lambda x: x[1]['pagerank'],
        reverse=True
    )[:10]

    return centrality_metrics, key_customers
```

### 4.2 社区检测
```python
def detect_communities(G):
    """检测客户社区"""

    # 使用Louvain算法进行社区检测
    from community import community_louvain

    # 只考虑客户节点
    customer_nodes = [n for n, d in G.nodes(data=True) if d['type'] == 'Customer']
    customer_subgraph = G.subgraph(customer_nodes)

    # 社区检测
    partition = community_louvain.best_partition(customer_subgraph)

    # 分析每个社区的特征
    communities = {}
    for node, community_id in partition.items():
        if community_id not in communities:
            communities[community_id] = []
        communities[community_id].append(node)

    # 计算社区指标
    community_stats = {}
    for community_id, members in communities.items():
        subgraph = customer_subgraph.subgraph(members)

        community_stats[community_id] = {
            'size': len(members),
            'density': nx.density(subgraph),
            'avg_clustering': nx.average_clustering(subgraph),
            'members': [G.nodes[n]['name'] for n in members]
        }

    return communities, community_stats
```

### 4.3 路径分析
```python
def find_relationship_paths(G, source_customer, target_customer, max_depth=4):
    """查找两个客户之间的关系路径"""

    source_node = f"CUST_{source_customer}"
    target_node = f"CUST_{target_customer}"

    try:
        # 查找最短路径
        shortest_path = nx.shortest_path(G, source_node, target_node)

        # 查找所有简单路径（避免无限循环）
        all_paths = []
        for path in nx.all_simple_paths(G, source_node, target_node, cutoff=max_depth):
            if len(path) <= max_depth + 1:
                path_info = []
                for i in range(len(path) - 1):
                    edge_data = G[path[i]][path[i+1]]
                    path_info.append({
                        'from': G.nodes[path[i]]['name'],
                        'to': G.nodes[path[i+1]]['name'],
                        'relation': edge_data.get('relation'),
                        'amount': edge_data.get('amount'),
                        'date': edge_data.get('date')
                    })
                all_paths.append(path_info)

        return {
            'shortest_path_length': len(shortest_path) - 1,
            'shortest_path': shortest_path,
            'all_paths': all_paths
        }

    except nx.NetworkXNoPath:
        return {
            'shortest_path_length': None,
            'shortest_path': None,
            'all_paths': []
        }
```

## 5. 反欺诈案例

### 5.1 欺诈模式识别
```python
def detect_fraud_patterns(G):
    """检测欺诈模式"""

    fraud_alerts = []

    # 1. 环形交易（资金闭环）
    cycles = list(nx.simple_cycles(G))
    for cycle in cycles:
        if len(cycle) >= 3:
            # 计算环路中的总金额
            total_amount = 0
            for i in range(len(cycle)):
                if G.has_edge(cycle[i], cycle[(i+1) % len(cycle)]):
                    total_amount += G[cycle[i]][cycle[(i+1) % len(cycle)]].get('amount', 0)

            if total_amount > 100000:  # 大额环形交易
                fraud_alerts.append({
                    'type': 'CIRCULAR_TRANSACTION',
                    'participants': [G.nodes[n]['name'] for n in cycle],
                    'total_amount': total_amount,
                    'risk_level': 'HIGH'
                })

    # 2. 集中度异常（单个账户连接过多客户）
    account_nodes = [n for n, d in G.nodes(data=True) if d['type'] == 'Account']
    for account in account_nodes:
        connected_customers = len(list(G.neighbors(account)))
        if connected_customers > 10:  # 异常集中度
            fraud_alerts.append({
                'type': 'HIGH_CONCENTRATION',
                'account': G.nodes[account]['number'],
                'connected_customers': connected_customers,
                'risk_level': 'MEDIUM'
            })

    # 3. 短时间内大量小额转账
    for node in G.nodes():
        if G.nodes[node]['type'] == 'Customer':
            edges = list(G.edges(node, data=True))
            # 按时间分组统计
            recent_transfers = [e for e in edges if e[2].get('relation') == 'TRANSFER_TO']
            if len(recent_transfers) > 50:  # 异常高频转账
                fraud_alerts.append({
                    'type': 'HIGH_FREQUENCY_TRANSFERS',
                    'customer': G.nodes[node]['name'],
                    'transfer_count': len(recent_transfers),
                    'risk_level': 'HIGH'
                })

    return fraud_alerts
```

### 5.2 关联风险传导
```python
def calculate_risk_propagation(G, initial_risk_nodes, decay_factor=0.8):
    """计算风险在图中的传播"""

    import numpy as np

    # 初始化风险值
    risk_scores = {node: 0.0 for node in G.nodes()}
    for node in initial_risk_nodes:
        if node in risk_scores:
            risk_scores[node] = 1.0

    # 迭代传播风险
    max_iterations = 10
    for iteration in range(max_iterations):
        new_risk_scores = risk_scores.copy()

        for node in G.nodes():
            if G.nodes[node]['type'] == 'Customer':
                # 计算来自邻居的风险
                neighbor_risk = 0.0
                for neighbor in G.neighbors(node):
                    neighbor_risk += risk_scores[neighbor] * decay_factor

                # 更新风险值
                new_risk_scores[node] = min(1.0, risk_scores[node] + neighbor_risk * 0.1)

        # 检查收敛
        change = sum(abs(new_risk_scores[n] - risk_scores[n]) for n in G.nodes())
        if change < 0.01:
            break

        risk_scores = new_risk_scores

    # 排序高风险客户
    high_risk_customers = [
        (node, score) for node, score in risk_scores.items()
        if G.nodes[node]['type'] == 'Customer' and score > 0.5
    ]
    high_risk_customers.sort(key=lambda x: x[1], reverse=True)

    return risk_scores, high_risk_customers
```

## 6. 实战演练

### 6.1 构建银行关系图谱
```python
import pandas as pd
import networkx as nx
import matplotlib.pyplot as plt

# 模拟银行数据
customers_df = pd.DataFrame({
    'customer_id': [1, 2, 3, 4, 5, 6],
    'customer_name': ['张三', '李四', '王五', '赵六', '钱七', '孙八'],
    'phone': ['13800138001', '13800138002', '13800138001', '13800138003', '13800138004', '13800138002'],
    'id_card': ['123456789012345678', '234567890123456789', '345678901234567890', '456789012345678901', '567890123456789012', '678901234567890123']
})

accounts_df = pd.DataFrame({
    'account_id': [101, 102, 103, 104, 105, 106, 107],
    'customer_id': [1, 1, 2, 3, 3, 4, 5],
    'account_number': ['6222021234567890', '6222021234567891', '6222021234567892', '6222021234567893', '6222021234567894', '6222021234567895', '6222021234567896'],
    'balance': [50000, 120000, 80000, 30000, 200000, 150000, 90000]
})

transactions_df = pd.DataFrame({
    'transaction_id': [1001, 1002, 1003, 1004, 1005, 1006, 1007],
    'from_account_id': [101, 102, 103, 104, 105, 106, 107],
    'to_account_id': [103, 104, 105, 106, 107, 101, 102],
    'amount': [10000, 20000, 50000, 15000, 30000, 8000, 12000],
    'transaction_date': ['2024-01-15', '2024-01-16', '2024-01-17', '2024-01-18', '2024-01-19', '2024-01-20', '2024-01-21']
})

# 构建知识图谱
bank_graph = build_customer_relationship_graph(customers_df, accounts_df, transactions_df)

# 分析图结构
print(f"图的基本统计:")
print(f"  节点数: {bank_graph.number_of_nodes()}")
print(f"  边数: {bank_graph.number_of_edges()}")

# 发现隐含关系
hidden_relations = discover_hidden_relationships(bank_graph)
print(f"\n发现的隐含关系: {len(hidden_relations)}")
for relation in hidden_relations:
    print(f"  {relation}")

# 中心性分析
centrality_metrics, key_customers = analyze_centrality(bank_graph)
print(f"\n关键客户 (按PageRank排序):")
for customer_id, metrics in key_customers[:3]:
    print(f"  {metrics['name']}: PageRank={metrics['pagerank']:.4f}")
```

## 7. 知识图谱练习题目

1. **基础构图**：根据客户-账户-交易数据构建知识图谱
2. **关系发现**：识别共享电话、地址的隐含关联
3. **中心性分析**：找出最有影响力的客户节点
4. **社区检测**：发现客户群体和异常聚类
5. **风险传导**：模拟风险在客户网络中的传播路径